### Добавление пакета щифрования. Исправление проблемы безопасности с восстановлением пароля

(section 8 video 109)

В прошлый раз мы обсуждали серьезную проблему безопасности в нашем приложении. Давайте разберем ее подробно и найдем решение.

#### Проблема
На странице восстановления пароля пользователь вводит свой email, после чего система отправляет ссылку для сброса пароля. Однако при просмотре исходного кода страницы можно увидеть email, который используется для восстановления пароля. Это значит, что злоумышленник может изменить его на другой email и сбросить пароль чужого пользователя.

#### Решение
Мы создадим пакет шифрования, который будет доступен и на фронтенде, и на бэкенде. Он позволит зашифровать email перед его передачей на сервер, а затем расшифровать его на бэкенде.

##### Шаг 1: Создание секретного ключа
Алгоритмы шифрования требуют ключа фиксированной длины — 32 символа. Мы задаем этот ключ в API (файл api.go) и в основном файле main.go.

##### Шаг 2: Создание нового пакета
В папке internal создаем новый пакет `encryption` и файл `encryption.go`.

##### Шаг 3: Определение структуры шифрования
Создаем структуру `Encryption`, которая содержит ключ шифрования в виде массива байтов.

##### Шаг 4: Функция шифрования
- Преобразуем переданный текст в массив байтов.
- Создаем шифровальный блок на основе ключа.
- Генерируем случайный вектор инициализации (IV).
- Используем алгоритм шифрования AES (режим CFB) для обработки текста.
- Кодируем результат в Base64, чтобы его можно было безопасно использовать в URL и HTML.

##### Шаг 5: Функция дешифрования
- Декодируем Base64 обратно в массив байтов.
- Создаем шифровальный блок.
- Проверяем, что длина шифрованного текста корректна.
- Извлекаем IV и расшифровываем данные.
- Преобразуем результат обратно в строку и возвращаем.

### Подробный разбор кода с комментариями

```go
package encryption

import (
	"crypto/aes"       // Подключаем библиотеку AES-шифрования
	"crypto/cipher"    // Подключаем методы работы с шифрами
	"crypto/rand"      // Генерация случайных значений
	"encoding/base64"  // Кодирование в Base64 для безопасной передачи
	"io"               // Ввод/вывод данных
)

// Структура для работы с шифрованием
type Encryption struct {
	Key []byte // Ключ шифрования (должен быть 32 байта)
}

// Функция шифрования
func (e *Encryption) Encrypt(text string) (string, error) {
	plaintext := []byte(text) // Преобразуем текст в массив байтов

	block, err := aes.NewCipher(e.Key) // Создаем новый шифровальный блок AES
	if err != nil {
		return "", err // Возвращаем ошибку, если не удалось создать блок
	}

	// Создаем массив для хранения зашифрованного текста + IV
	cipherText := make([]byte, aes.BlockSize+len(plaintext))
	iv := cipherText[:aes.BlockSize] // Первая часть массива - IV

	// Генерируем случайное значение для IV
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	// Создаем шифратор CFB (Cipher Feedback Mode)
	stream := cipher.NewCFBEncrypter(block, iv)
	// Шифруем текст
	stream.XORKeyStream(cipherText[aes.BlockSize:], plaintext)

	// Кодируем зашифрованный текст в Base64 для безопасной передачи
	return base64.URLEncoding.EncodeToString(cipherText), nil
}

// Функция дешифрования
func (e *Encryption) Decrypt(cryptoText string) (string, error) {
	// Декодируем из Base64
	cipherText, _ := base64.URLEncoding.DecodeString(cryptoText)

	block, err := aes.NewCipher(e.Key) // Создаем блок дешифрования
	if err != nil {
		return "", err
	}

	// Проверяем корректность длины зашифрованного текста
	if len(cipherText) < aes.BlockSize {
		return "", err
	}

	// Извлекаем IV из первой части массива
	iv := cipherText[:aes.BlockSize]
	cipherText = cipherText[aes.BlockSize:]

	// Создаем расшифровщик CFB
	stream := cipher.NewCFBDecrypter(block, iv)
	// Дешифруем текст
	stream.XORKeyStream(cipherText, cipherText)

	return string(cipherText), nil // Преобразуем результат обратно в строку
}
```

### Вывод
Теперь email-адрес пользователя передается в зашифрованном виде, что предотвращает возможность его подмены злоумышленником. Мы использовали AES-шифрование с режимом CFB и кодирование Base64 для безопасной передачи. Этот механизм позволяет защитить систему восстановления пароля от атак.

